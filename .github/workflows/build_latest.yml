name: Build and release 'latest'

on:
    push:
        branches:
            - master
    workflow_dispatch:

permissions:
    contents: write

jobs:
    build-and-release:
        runs-on: ubuntu-latest

        steps:
            - name: Checkout
              uses: actions/checkout@v4

            - name: Set up JDK 23
              uses: actions/setup-java@v4
              with:
                distribution: temurin
                java-version: '23'

            - name: Build (detect mvn/gradle)
              run: |
                    if [ -f mvnw ]; then
                        chmod +x mvnw
                        ./mvnw -B -DskipTests package
                    elif [ -f pom.xml ]; then
                        mvn -B -DskipTests package
                    elif [ -f gradlew ]; then
                        chmod +x gradlew
                        ./gradlew -x test build
                    elif [ -f build.gradle ] || [ -f build.gradle.kts ]; then
                        ./gradlew -x test build
                    else
                        echo "No recognized Java build system (pom.xml, mvnw, gradlew) found."
                        exit 1
                    fi

            - name: Find built JAR
              id: find_artifact
              run: |
                    jar=$(find . -type f -name "*.jar" -not -path "*/.gradle/*" -not -path "*/.mvn/*" | head -n1 || true)
                    if [ -z "$jar" ]; then
                        echo "No JAR artifact found"
                        exit 1
                    fi
                    echo "jar_path=$jar" >> $GITHUB_OUTPUT

            - name: Create or update tag 'latest'
              run: |
                    git config user.name "github-actions[bot]"
                    git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
                    # Tag the current HEAD as 'latest' and force-push the tag to origin
                    git tag -fa latest -m "latest"
                    git push --force origin refs/tags/latest

            - name: Prepare release asset
              id: prep_asset
              run: |
                jar_path="${{ steps.find_artifact.outputs.jar_path }}"
                echo "asset_path=$jar_path" >> $GITHUB_OUTPUT
                echo "asset_name=$(basename \"$jar_path\")" >> $GITHUB_OUTPUT

            - name: Find or create release and delete existing asset
              id: release_manage
              uses: actions/github-script@v6
              env:
                ASSET_NAME: ${{ steps.prep_asset.outputs.asset_name }}
              with:
                github-token: ${{ secrets.GITHUB_TOKEN }}
                script: |
                  const tag = 'latest'
                  const repo = context.repo
                  const assetName = process.env.ASSET_NAME

                  // Try to get release by tag, create if missing
                  let release
                  try {
                    release = await github.rest.repos.getReleaseByTag({ owner: repo.owner, repo: repo.repo, tag })
                  } catch (err) {
                    if (err.status === 404) {
                      release = await github.rest.repos.createRelease({ owner: repo.owner, repo: repo.repo, tag_name: tag, name: tag, body: 'Release latest', draft: false, prerelease: false })
                    } else {
                      throw err
                    }
                  }

                  const releaseId = release.data.id
                  const uploadUrl = release.data.upload_url

                  // Delete existing asset with the same name if present
                  const assets = await github.rest.repos.listReleaseAssets({ owner: repo.owner, repo: repo.repo, release_id: releaseId })
                  for (const asset of assets.data) {
                    if (asset.name === assetName) {
                      await github.rest.repos.deleteReleaseAsset({ owner: repo.owner, repo: repo.repo, asset_id: asset.id })
                    }
                  }

                  // Return values (github-script exposes returned value as `steps.<id>.outputs.result`)
                  return { release_id: releaseId, upload_url: uploadUrl }

            - name: Upload release asset (curl)
              env:
                GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
              run: |
                set -e
                upload_url="${{ fromJson(steps.release_manage.outputs.result).upload_url }}"
                # upload_url from GitHub API includes a template like: https://uploads.github.com/.../assets{?name,label}
                upload_url_base="${upload_url%%\{*}"
                asset_path="${{ steps.prep_asset.outputs.asset_path }}"
                asset_name="${{ steps.prep_asset.outputs.asset_name }}"
                echo "Uploading $asset_name to $upload_url_base"
                curl --fail -H "Authorization: token $GITHUB_TOKEN" -H "Content-Type: application/java-archive" --data-binary @"$asset_path" "$upload_url_base?name=$(printf '%s' "$asset_name" | jq -s -R -r @uri)"